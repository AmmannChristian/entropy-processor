# Entropy Processor -- Quarkus Application Configuration
#
# Central configuration for the entropy-processor microservice. Properties are
# grouped by subsystem. Environment variables (${VAR:default}) allow per-
# environment overrides without modifying this file.
#
# Profile conventions used throughout:
#   %dev  -- local development (self-signed certificates, relaxed TLS)
#   %prod -- production deployment (Vault-managed certificates, strict mTLS)

#
# Global Feature Flags
#
# Master switch for OIDC / RBAC enforcement. Set to false only for local
# integration testing without an identity provider.
entropy.security.enabled=${SECURITY_ENABLED:true}

#
# Database -- TimescaleDB (PostgreSQL)
#
# The application expects a TimescaleDB-enabled PostgreSQL instance. Schema
# migrations are managed by Flyway; Hibernate is configured to validate only.
quarkus.datasource.db-kind=postgresql
quarkus.datasource.username=${DB_USER:postgres}
quarkus.datasource.password=${DB_PASSWORD:entropy}
quarkus.datasource.jdbc.url=jdbc:postgresql://${DB_HOST:localhost}:${DB_PORT:5432}/${DB_NAME:entropy_db}
quarkus.hibernate-orm.schema-management.strategy=validate
quarkus.hibernate-orm.log.sql=false
# Batch size for JDBC prepared-statement batching (improves bulk-insert throughput).
quarkus.hibernate-orm.jdbc.statement-batch-size=100

# Dev profile database overrides
%dev.quarkus.datasource.jdbc.url=jdbc:postgresql://${DB_HOST:localhost}:${DB_PORT:5432}/${DB_NAME:entropy_db}
%dev.quarkus.datasource.username=${DB_USER:postgres}
%dev.quarkus.datasource.password=${DB_PASSWORD:postgres}

#
# gRPC Server
#
# The gRPC server shares the Vert.x HTTP server (same port). This avoids
# opening a second TCP listener and allows a single TLS termination point.
quarkus.grpc.server.use-separate-server=false
quarkus.grpc.server.enable-reflection-service=${GRPC_ENABLE_REFLECTION_SERVICE:true}
# Maximum inbound message size in bytes (default: 10 MiB).
quarkus.grpc.server.max-inbound-message-size=${GRPC_MAX_INBOUND_MESSAGE_SIZE:10485760}

# Dedicated management interface for health and metrics (port 9090).
quarkus.management.enabled=true
quarkus.management.port=9090

#
# HTTP Server (shared with gRPC)
#
# Plaintext port 9080 and TLS port 9443. Both HTTP/1.1 and HTTP/2 (h2) are
# served on the same listener; gRPC clients negotiate h2 via ALPN.
quarkus.http.host=${HTTP_HOST:0.0.0.0}
quarkus.http.port=9080
quarkus.http.ssl-port=9443
quarkus.http.cors.enabled=${HTTP_CORS_ENABLED:true}
quarkus.http.cors.origins=${HTTP_CORS_ORIGINS:/.*/}
quarkus.http.cors.methods=${HTTP_CORS_METHODS:GET,POST,PUT,DELETE,OPTIONS}
quarkus.http.cors.headers=${HTTP_CORS_HEADERS:accept,authorization,content-type,x-requested-with}
quarkus.http.cors.exposed-headers=${HTTP_CORS_EXPOSED_HEADERS:content-disposition}
quarkus.http.http2=${HTTP2_ENABLED:true}

#
# Mutual TLS (mTLS) -- shared HTTP / gRPC listener
#
# All production traffic requires mutual TLS. The server presents its
# certificate and demands a valid client certificate signed by the trusted CA.
quarkus.http.insecure-requests=${HTTP_INSECURE_REQUESTS:disabled}
quarkus.http.ssl.client-auth=${HTTP_SSL_CLIENT_AUTH:required}
quarkus.http.tls-configuration-name=grpc-mtls


# Dev profile: PKCS#12 keystores with self-signed certificates.
%dev.quarkus.tls.grpc-mtls.key-store.p12.path=certs/server.p12
%dev.quarkus.tls.grpc-mtls.key-store.p12.password=changeit
%dev.quarkus.tls.grpc-mtls.trust-store.p12.path=certs/ca.p12
%dev.quarkus.tls.grpc-mtls.trust-store.p12.password=changeit
%dev.quarkus.tls.grpc-mtls.reload-period=15m

# Production: PKCS#12 certificates provisioned by Vault Agent.
%prod.quarkus.tls.grpc-mtls.key-store.p12.path=${GRPC_KEY_STORE:/certs/server.p12}
%prod.quarkus.tls.grpc-mtls.key-store.p12.password=${GRPC_KEY_STORE_PASSWORD:changeit}
%prod.quarkus.tls.grpc-mtls.trust-store.p12.path=${GRPC_TRUST_STORE:/certs/ca.p12}
%prod.quarkus.tls.grpc-mtls.trust-store.p12.password=${GRPC_TRUST_STORE_PASSWORD:changeit}
%prod.quarkus.tls.grpc-mtls.reload-period=1m

# Certificate verification policy.
quarkus.tls.grpc-mtls.trust-all=${GRPC_MTLS_TRUST_ALL:false}
quarkus.tls.grpc-mtls.hostname-verification-algorithm=${GRPC_MTLS_HOSTNAME_VERIFICATION_ALGORITHM:HTTPS}

#
# NIST SP 800-22 gRPC Client -- Statistical Randomness Test Suite
#
quarkus.grpc.clients.sp80022-test-service.host=${NIST_SP800_22_HOST:nist-sp800-22}
quarkus.grpc.clients.sp80022-test-service.port=${NIST_SP800_22_PORT:50051}
quarkus.grpc.clients.sp80022-test-service.plain-text=${NIST_SP800_22_PLAINTEXT:false}
quarkus.grpc.clients.sp80022-test-service.tls.trust-certificate-pem.certs=${GRPC_CA_CERT:/certs/ca.crt}

#
# NIST SP 800-90B gRPC Client -- Entropy Source Assessment
#
quarkus.grpc.clients.sp80090b-assessment-service.host=${NIST_SP800_90B_HOST:nist-sp800-90b}
quarkus.grpc.clients.sp80090b-assessment-service.port=${NIST_SP800_90B_PORT:50051}
quarkus.grpc.clients.sp80090b-assessment-service.plain-text=${NIST_SP800_90B_PLAINTEXT:false}
quarkus.grpc.clients.sp80090b-assessment-service.tls.trust-certificate-pem.certs=${GRPC_CA_CERT:/certs/ca.crt}

# Health-check gRPC clients reuse the same host and port as their respective
# test/assessment services but require separate named client registrations.
quarkus.grpc.clients.sp80022-health-service.host=${NIST_SP800_22_HOST:nist-sp800-22}
quarkus.grpc.clients.sp80022-health-service.port=${NIST_SP800_22_PORT:50051}
quarkus.grpc.clients.sp80022-health-service.plain-text=${NIST_SP800_22_PLAINTEXT:false}
quarkus.grpc.clients.sp80022-health-service.tls.trust-certificate-pem.certs=${GRPC_CA_CERT:/certs/ca.crt}

quarkus.grpc.clients.sp80090b-health-service.host=${NIST_SP800_90B_HOST:nist-sp800-90b}
quarkus.grpc.clients.sp80090b-health-service.port=${NIST_SP800_90B_PORT:50051}
quarkus.grpc.clients.sp80090b-health-service.plain-text=${NIST_SP800_90B_PLAINTEXT:false}
quarkus.grpc.clients.sp80090b-health-service.tls.trust-certificate-pem.certs=${GRPC_CA_CERT:/certs/ca.crt}

# NIST service readiness probes. When "required" is true the application
# readiness check will fail if the NIST service is unreachable.
nist.sp80022.health.required=${NIST_SP800_22_HEALTH_REQUIRED:false}
nist.sp80022.health.timeout=${NIST_SP800_22_HEALTH_TIMEOUT:5s}
nist.sp80090b.health.required=${NIST_SP800_90B_HEALTH_REQUIRED:false}
nist.sp80090b.health.timeout=${NIST_SP800_90B_HEALTH_TIMEOUT:5s}

#
# OIDC -- Inbound Token Validation (ZITADEL)
#
# The service acts as a resource server (application-type=service). Incoming
# Bearer tokens are validated locally (JWT) or via introspection (opaque).
quarkus.oidc.application-type=service
quarkus.oidc.auth-server-url=${OIDC_AUTH_SERVER_URL}
quarkus.oidc.client-id=${OIDC_CLIENT_ID}

# OIDC discovery and JWKS endpoint.
quarkus.oidc.discovery-enabled=true
quarkus.oidc.jwks-path=/oauth/v2/keys

# Client authentication towards the IdP uses private_key_jwt (RFC 7523).
quarkus.oidc.credentials.jwt.key-file=${OIDC_JWT_KEY_FILE:src/main/resources/secrets/private-key-pkcs8.pem}
quarkus.oidc.credentials.jwt.token-key-id=${OIDC_JWT_KEY_ID}
# JWT lifetime in seconds used when authenticating this service to the IdP.
quarkus.oidc.credentials.jwt.lifespan=${OIDC_JWT_LIFESPAN:300}
quarkus.oidc.credentials.jwt.audience=${quarkus.oidc.auth-server-url}

# Token validation constraints.
quarkus.oidc.token.issuer=${quarkus.oidc.auth-server-url}
quarkus.oidc.token.audience=${OIDC_TOKEN_AUDIENCE:${quarkus.oidc.client-id}}
quarkus.oidc.token.verify-access-token-with-user-info=false

# Opaque token support. When an incoming token is not a JWT, the service
# performs an introspection call to the IdP instead of local verification.
quarkus.oidc.token.allow-opaque-token-introspection=true
quarkus.oidc.token.allow-jwt-introspection=false

# ZITADEL-specific introspection endpoint.
quarkus.oidc.introspection-path=oauth/v2/introspect
quarkus.oidc.introspection-credentials-name=default

# ZITADEL encodes project-scoped roles under a URN-based claim.
quarkus.oidc.roles.source=accesstoken
quarkus.oidc.roles.role-claim-path=urn:zitadel:iam:org:project:roles

# OIDC connection tuning.
quarkus.oidc.connection-timeout=${OIDC_CONNECTION_TIMEOUT:10s}
quarkus.oidc.connection-delay=0
quarkus.oidc.connection-retry-count=${OIDC_CONNECTION_RETRY_COUNT:3}
quarkus.oidc.max-pool-size=${OIDC_MAX_POOL_SIZE:20}

# In-memory cache for validated tokens. Reduces introspection calls for
# repeated requests carrying the same opaque token.
quarkus.oidc.token-cache=true
quarkus.oidc.token-cache.max-size=${OIDC_TOKEN_CACHE_MAX_SIZE:1000}
quarkus.oidc.token-cache.time-to-live=${OIDC_TOKEN_CACHE_TTL:600s}

#
# HTTP Authorization Policies
#
# Health, metrics, OpenAPI, and gRPC reflection/health endpoints are public.
# gRPC data endpoints are protected separately by OidcAuthInterceptor.
quarkus.http.auth.permission.public.paths=/q/health/*,/q/metrics,/q/openapi,/q/openapi/*,/grpc.health.*,/grpc.reflection.*
quarkus.http.auth.permission.public.policy=permit

# All REST API paths require a valid Bearer token.
quarkus.http.auth.permission.authenticated.paths=/api/*
quarkus.http.auth.permission.authenticated.policy=authenticated

#
# Dev-Profile TLS Relaxation
#
# In development, outbound HTTP calls to the IdP skip host verification
# because local environments typically use self-signed certificates.
%dev.quarkus.rest-client.auth.verify-host=false
%dev.quarkus.tls.authdev.trust-all=true
%dev.quarkus.tls.authdev.hostname-verification-algorithm=NONE
%dev.quarkus.oidc.tls.tls-configuration-name=authdev
%dev.quarkus.oidc-client.tls.tls-configuration-name=authdev

#
# OIDC Client -- Outbound Client-Credentials Flow
#
# Used by NistValidationService to obtain a service token for calling the
# external NIST gRPC services. Authenticates via private_key_jwt.
quarkus.oidc-client.auth-server-url=${NIST_OIDC_URL:${quarkus.oidc.auth-server-url}}
quarkus.oidc-client.client-id=${NIST_OIDC_CLIENT_ID:${quarkus.oidc.client-id}}
quarkus.oidc-client.grant.type=client
quarkus.oidc-client.scopes=openid

quarkus.oidc-client.credentials.jwt.key-file=${OIDC_JWT_KEY_FILE:src/main/resources/secrets/private-key-pkcs8.pem}
quarkus.oidc-client.credentials.jwt.token-key-id=${OIDC_JWT_KEY_ID}
quarkus.oidc-client.credentials.jwt.lifespan=${OIDC_JWT_LIFESPAN:300}
quarkus.oidc-client.credentials.jwt.audience=${quarkus.oidc-client.auth-server-url}

# Proactive token refresh. Quarkus re-fetches a new token this many seconds
# before the current one expires to avoid request failures.
quarkus.oidc-client.refresh-token-time-skew=30S

#
# Scheduler (Quartz)
#
quarkus.scheduler.enabled=${SCHEDULER_ENABLED:true}
# Job store type. "ram" keeps schedules in memory (no cluster support).
quarkus.quartz.store-type=${QUARTZ_STORE_TYPE:ram}

#
# Metrics (Micrometer / Prometheus)
#
quarkus.micrometer.export.prometheus.enabled=${PROMETHEUS_ENABLED:true}
quarkus.micrometer.binder.jvm=${METRICS_JVM_ENABLED:true}
quarkus.micrometer.binder.grpc-server.enabled=${METRICS_GRPC_SERVER_ENABLED:true}

#
# Flyway -- Database Migration
#
# Migrations run automatically on startup. In dev, the database is cleaned
# before migration to ensure a reproducible schema.
quarkus.flyway.migrate-at-start=${FLYWAY_MIGRATE_AT_START:true}
quarkus.flyway.baseline-on-migrate=${FLYWAY_BASELINE_ON_MIGRATE:true}
%dev.quarkus.flyway.clean-at-start=${FLYWAY_CLEAN_AT_START:true}

#
# Logging
#
quarkus.log.level=${LOG_LEVEL:INFO}
quarkus.log.category."com.ammann.entropy".level=DEBUG
quarkus.log.category."io.grpc".level=DEBUG
quarkus.log.category."io.quarkus.grpc".level=DEBUG

#
# Entropy Source Configuration
#
# Expected detector count rate in Hz. This value is used for both event rate
# deviation checks and decay interval plausibility. The expected interval and
# acceptable range are derived from this rate to ensure consistency.
# Adjust this value to match the actual detector count rate of your setup.
entropy.source.expected-rate-hz=${ENTROPY_EXPECTED_RATE_HZ:184}

#
# Kernel Entropy Writer
#
# Feeds validated entropy bytes into the Linux kernel random pool. The writer
# opens the configured character device and issues RNDADDENTROPY ioctls.
kernel.entropy.writer.enabled=${KERNEL_WRITER_ENABLED:false}
kernel.entropy.writer.device=${KERNEL_WRITER_DEVICE:/dev/random}
# Scheduling interval for the kernel entropy writer (Quarkus duration format).
kernel.entropy.writer.interval=${KERNEL_WRITER_INTERVAL:5s}
